'use strict';

var fs = require('fs'),
    path = require('path'),
    util = require('util'),
    assert = require('assert'),
    pputil = require('../pputil'),
    cdbutils = require('./cdbutils'),
    keywrap = require('../keywrap');

var SERVER_SESSION_CDB = 'server_sessions.cdb';

exports = module.exports = {

    supports: function (options, callback) {
        fs.exists(path.join(options.dir, SERVER_SESSION_CDB), function (result) {
            callback(null, result);
        });
    },


    create: function (options, config, callback) {
        var rfc, pin = process.env[options.pinName];

        assert(pin, 'No pin set.');

        pin = pputil.base64Decode(pin);

        rfc = keywrap.createKeyWrapper('rfc5649');

        cdbutils.readCdb(path.join(options.dir, SERVER_SESSION_CDB), function (error, cdbData) {
            var kek, result = {};

            if (!error) {
                kek = rfc.unwrap(config.get(cdbData.session_encryption_key), pin.slice(0, 16));

                Object.keys(cdbData).forEach(function (key) {
                    var value;
                    //We discard everything except the sessions.
                    if (key.indexOf('encrypted_ssl_session_universalaes') > -1) {
                        value = pputil.base64Decode(cdbData[key]);
                        if (pputil.isEncrypted(key)) {
                            value = rfc.unwrap(value, kek);
                        }
                        //Strip everything but date (e.g. 20130324)from key name since it isn't encrypted anymore.
                        result[key.substr(key.length - 8)] = value.toString('base64');
                    }
                });

                config.set('server_sessions', result);
                config.set('server_session_id_context', cdbData.session_id_context);
            }

            callback(error, config);
        });
    }

};


