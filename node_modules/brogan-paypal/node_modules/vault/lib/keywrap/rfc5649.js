'use strict';

var equal = require('buffer-equal');
var keywrap = require('./keywrap');
var crypto = require('crypto');
var assert = require('assert');

var AIV_CONSTANT = new Buffer('A65959A6', 'hex');


function wrap(plaintext, kek) {
    assert(Buffer.isBuffer(plaintext), 'plaintext must be a Buffer');
    assert(Buffer.isBuffer(kek), 'kek must be a Buffer');
    
    var aiv = createAIV(plaintext);
    var paddedText = padText(plaintext);
    var algorithm, cipher, ciphertext;
    var constructed;

    if (plaintext.length <= 8) {
        constructed = Buffer.concat([aiv, paddedText]);
        algorithm = 'aes-' + kek.length * 8 + '-ecb';

        cipher = crypto.createCipheriv(algorithm, kek, '');
        cipher.setAutoPadding(false);
        ciphertext = Buffer.concat([cipher.update(constructed), cipher.final()]);
        
        return ciphertext;
    } else {
        // RFC3394(aiv, paddedText);
        return keywrap.wrap(paddedText, kek, aiv);
    }
}


function padText(plaintext) {
    // pad to nearest 64b block
    var size = (plaintext.length + 7) & ~7;
    var padded = new Buffer(size);
    padded.fill(0);
    plaintext.copy(padded);
    
    return padded;
}

function createAIV(plaintext) {
    var aiv = new Buffer(8);

    AIV_CONSTANT.copy(aiv);
    aiv.writeUInt32BE(plaintext.length, 4);
    
    return aiv;
}


function unwrap(ciphertext, kek) {
    assert(Buffer.isBuffer(ciphertext), 'ciphertext must be a Buffer');
    assert(Buffer.isBuffer(kek), 'kek must be a Buffer');

    var inlen, components, key, plaintext;
    var algorithm, decipher;
    
    
    inlen = ciphertext.length;
    
    // ciphertext must be n>=2 64-bit (16B) blocks
    if (inlen % 8 || inlen < 16) {
        return undefined;
    }
     
    if (inlen === 16) {

        // decrypt as single AES block (ECB) with kek
        algorithm = 'aes-' + kek.length * 8 + '-ecb';
        decipher = crypto.createDecipheriv(algorithm, kek, '');
        decipher.setAutoPadding(false);
        plaintext = Buffer.concat([decipher.update(ciphertext), decipher.final()]);
    } else {
        // RFC3394(ciphertext, kek)
        plaintext = keywrap.unwrap(ciphertext, kek);
    }
    
    components = getComponents(plaintext);

    if (!(validAIV(components))) {
        return undefined;
    }

    key = components.paddedKey.slice(0, components.mli);
    return key;
}


function getComponents(plaintext) {
    var aiv, paddedKey, constant, mli;

    aiv = plaintext.slice(0, 8); // first 64B
    paddedKey = plaintext.slice(8);
    constant = aiv.slice(0,4); // MSB(32, aiv)
    mli = aiv.readUInt32BE(4); // LSB(32, aiv) (Big-Endian)
    
    return {
        aiv: aiv,
        paddedKey: paddedKey,
        constant: constant,
        mli: mli
    }; 
}


function validAIV(components) {
    var n, b, padding, empty;

    // Step 1: validate constant
    if (!equal(components.constant, AIV_CONSTANT)) {
        return false;
    }
    
    // Step 2: validate MLI
    n = components.paddedKey.length / 8;
    if ((components.mli <= 8 * (n-1)) || (components.mli > 8 * n)) {
        return false;
    }
    
    // Step 3: check padding
    b = (8 * n) - components.mli;
    padding = components.paddedKey.slice(components.mli, components.mli + b);

    empty = new Buffer(b);
    empty.fill(0);
    if (!equal(padding, empty)) {
        return false;
    }
    
    return true;
}



exports = module.exports = {

    wrap: wrap,

    unwrap: unwrap

};
