/**
 *
 * Responsible for generating meta information for any app using nodejs
 */
'use strict';

var SECONDS_PER_DAY = 86400,
    SECONDS_PER_HOUR = 3600,
    SECONDS_PER_MINUTE = 60;

var os = require('os'),
    fs = require('fs'),
    path = require('path'),
    util = require('util'),
    utils = require('./utils'),
    ecvCheck = require('ecv-paypal')(),
    tryRequire = require('try-require'),
    debug = require('debuglog')('meta');

var root = process.cwd(),
    pkgJson = require(path.join(root, 'package.json')),
    metaJson = tryRequire(path.join(root, 'manifest.json')),
    cdbsLayoutJson = tryRequire(path.join(root, 'cdbs', 'layout.json')),
    aggregatedModules,
    stack = [];

/**
 * function to aggregate the modules being used in the app
 * @param data - array of package names and their versions
 * @param dir - root of the app
 * @param pkgs - package.json file of the app
 * @param callback - callback to module.exports where moduleAggregator was invoked
 */

function aggregateModules(dir, pkgs, callback) {
    var dep = pkgs.dependencies,
        mod,
        data = [],
        size = 0,
        counter = 0,
        pkg = {};
    Object.keys(dep).forEach(function (key) {
        size++;
        var modPath = path.join(dir, 'node_modules', key, 'package.json');
        fs.exists(modPath, function (exists) {
            counter++;
            if (exists) {
                pkg = {};
                mod = require(modPath);
                pkg.name = mod.name;
                pkg.version = mod.version;
                data.push(pkg);
            }
            if (counter === size) {
                aggregatedModules = data;
                callback(null, data);
            }
        });

    });

}

/**
 * initial invocation to aggregate module information
 * @param callback - callback to the module.exports
 */

function moduleAggregator(callback) {
    if (aggregatedModules) {
        callback(null, aggregatedModules);
    } else {
        aggregateModules(root, pkgJson, callback);
    }
}

/**
 * function that returns the memory usage details for the app
 */
var getUsage = function () {
    var data = {},
        mem;
    mem = util.inspect(process.memoryUsage());
    data.total = parseInt(mem.split(' ')[4].replace(/,+$/, ''), 10);
    data.used = parseInt(mem.split(' ')[6], 10);
    return data;
};



/**
 * function to obtained the various process related information
 */
var getProcessInfo = function () {
    var totalSec = process.uptime(),
        days = Math.floor(totalSec / SECONDS_PER_DAY),
        hours = Math.floor((totalSec % SECONDS_PER_DAY) / SECONDS_PER_HOUR),
        minutes = Math.floor(((totalSec % SECONDS_PER_DAY) % SECONDS_PER_HOUR) / SECONDS_PER_MINUTE),
        seconds = totalSec % 60,
        sec = seconds.toFixed(),
        result = days + ' days ' + hours + ' hrs ' + minutes + ' min ' + sec + ' secs',
        process_info = {};
    process_info.uptime = result;
    process_info.deployEnv = process.env.DEPLOY_ENV;
    process_info.nodeEnv = process.env.NODE_ENV;
    process_info.platform = process.platform;
    process_info.architecture = process.arch;
    process_info.clusterInstances = metaJson && metaJson.info && metaJson.info.clusterInstance || '1';
    process_info.cwd = process.cwd();
    return process_info;
};

module.exports = function meta() {

    return function meta(req, res, next) {
        res.setHeader('Cache-Control', 'no-cache');
        var url,
            urlLength,
            model = {},
            checkUrl,
            metaStartTime = Date.now(),
            execTime,
            params = {};

        url = req.url.replace(/\/\//g, '/');
        urlLength = url.length;

        if (url.charAt(urlLength - 1) === '/') {
            url = url.substr(0, urlLength - 1);
        }

        url = url.split('/');
        checkUrl = url[url.length - 1];

        model = req.meta || {};
        if (checkUrl === 'ecv') {
            ecvCheck(req, res, next);

        } else if (checkUrl === 'meta') {
            if (!req.isInternalRequest) {
                res.statusCode = 404;
                res.end();
                return;
            }

            var pageInfo, links;

            if (res.locals && res.locals.context) {
                pageInfo =  res.locals.context.pageInfo;
                links = res.locals.context.links;
            } else {
                pageInfo = {};
                links = {};
            }

            if (req.showDebugInfo) {    //more restricted access
                model.scm = (pageInfo.debug && pageInfo.debug.scm) || {};
                model.appInfo = (pageInfo.debug && pageInfo.debug.version) || {};
                model.appInfo.appName = req.appName || '';

                model.resourceBaseUrl = links.resourceBaseUrl || '';
                model.hostname = os.hostname();
                model.memory = getUsage();
                model.processInfo = getProcessInfo();
                model.middleware = utils.getMiddlewareInfo(req);
                model.routes = utils.getRoutes(req);
                model.services = utils.getServiceInfo(req);
                if (cdbsLayoutJson) {
                    model.cdbsLayout = cdbsLayoutJson;
                }
                moduleAggregator(function (err, result) {
                    if (!err) {
                        model.pkg = result;
                    }
                    execTime = Date.now() - metaStartTime;
                    model.executionTime = execTime + 'ms';
                    res.json(model);
                });
            } else {
                //show only appName and manifestId
                model.appInfo = (pageInfo.debug && pageInfo.debug.version) || {};
                model.appInfo.appName = req.appName || '';
                execTime = Date.now() - metaStartTime;
                model.executionTime = execTime + 'ms';
                res.json(model);
            }
        } else {
            return next();
        }
    };
};
