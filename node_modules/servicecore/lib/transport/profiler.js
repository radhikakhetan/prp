'use strict';

var assert = require('assert'),
    utils = require('./../utils'),
    objutil = require('objutil'),
    cal = utils.tryRequire('cal'),
    querystring = require('querystring'),
    os = require('os'),
    thing = require('core-util-is'),
    timeoutengine = require('timeoutengine'),
    debug = require('debuglog')('servicecore');

/**
 * Wraps the given (transport) function for CAL logging / profiling.
 * @type {exports}
 */
exports = module.exports = function () {
    var cls, profiler, start, end;

    cls = utils.localStorage();

    /**
     * Wrapped transport function.
     * @param options - the transport specific options.
     * @param callback
     * @returns {*}
     */
    profiler = function profile(options, callback, invoke) {
        var req, originalCallback, appName, correlationId, poolStack,
            pageStartTime, txnStart, hostName, clientIp, remoteAddress, fraudnetData,
            txn, txname, profileHeaders, threadId,
            connectTxname, connectTxn, connectEvent, socketTxn;

        appName = cls.get('appName');
        correlationId = cls.get('correlationId');
        pageStartTime = cls.get('pageStartTime');
        clientIp = cls.get('ip');
        remoteAddress = cls.get('remoteAddress');
        fraudnetData = cls.get('fn_dt');
        threadId = cls.get('threadId');

        txname = utils.getTransactionName(options);
        originalCallback = callback;
        connectEvent = options.protocol === 'https:' ? 'secureConnect' : 'connect';
        connectTxname = (options.rawHostname || options.hostname) + ':' + options.port;

        if (!cal || !correlationId) {
            debug('no CAL context, skipping profile.');
            invoke(options, callback);
            return;
        }

        hostName = os.hostname();
        txnStart = (pageStartTime || 0).toString(16);
        poolStack = appName + ':' + txname + '*CalThreadId=0*TopLevelTxnStartTime=' + txnStart + '*Host=' + hostName;

        options.headers = options.headers || {};

        options.clientInfo = {
            host: hostName,
            calPoolName: appName,
            pid: process.pid,
            ip: clientIp,
            poolStack: poolStack
        };

        //CAL-centric headers.
        profileHeaders = {
            'pp_remote_addr': remoteAddress,
            'fn_dt': fraudnetData,
            'correlation-id': correlationId,
            'x-pp-corrid': correlationId,
            'x-pp-show-serverinfo': true,
            'client_info': poolStack
        };

        objutil.merge(profileHeaders, options.headers);

        if (!options.caltxn) {
            txn = cal.createTransaction('CALL_A', txname);
            txn.threadId = threadId;
            txn.correlationId = correlationId;
            txn.addData({
                timeout: options.socketTimeout,
                useAdaptiveTimeout: !!options.useAdaptiveTimeout,
                adaptiveTimeout: options.adaptiveSocketTimeout,
                method: options.method,
                path: scrub(options.path)
            });

            options.caltxn = txn;
        }

        txn = options.caltxn;

        cls.set('caltxn', txn);

        //Wrap callback for CAL transaction completion.
        callback = function (error, response) {
            var body;
            req.removeListener('socket', onSocket);
            req.socket.removeListener(connectEvent, onSocketConnect);

            if (error) {
                if (connectTxn) {
                    if (error.code === 'ETIMEDOUT') {
                        connectTxn.addData({
                            error: error.message
                        });
                        if (options.retry) {
                            connectTxn.addData({
                                retry: options.retry,
                                maxRetry: options.maxRetry
                            });
                        }
                    }

                    connectTxn.status = cal.Status.ERROR;
                    connectTxn.complete();
                    timeoutengine.addConnectDuration(options.clientName, connectTxn.duration);
                }

                if (error.code !== 'ETIMEDOUT' || options.retry >= options.maxRetry) {
                    txn.status = cal.Status.ERROR;
                    txn.addData({
                        error: error.message
                    });

                    txn.complete();
                    timeoutengine.addSocketDuration(options.clientName, txn.duration);
                }

                originalCallback.apply(null, arguments);

                return;
            }

            txn.status = cal.Status.SUCCESS;
            txn.addData({ statusCode: response.statusCode });

            if (response.statusCode && response.statusCode >= 500) {
                body = response.body;

                if (body && Buffer.isBuffer(body)) {
                    body = body.toString();
                }

                txn.status = cal.Status.ERROR;
                txn.addData({ message: body });
            }

            if (response.headers && response.headers.server_info) {
                logServerInfo(response.headers.server_info);
                debug('%s server info: %s', txname, response.headers.server_info);
            }

            txn.complete();
            timeoutengine.addSocketDuration(options.clientName, txn.duration);
            originalCallback.apply(null, arguments);
        };

        debug('profiling %s: clientinfo %s', txname, profileHeaders.client_info);

        socketTxn = cal.createTransaction('SOCKET', connectTxname);
        socketTxn.threadId = threadId;

        req = invoke(options, callback);

        req.once('socket', onSocket);

        function onSocket(socket) {
            var connected = connectEvent === 'secureConnect' && socket.socket ? !socket.socket._connecting : (!socket._connecting && !socket.connecting);

            socket.removeListener(connectEvent, onSocketConnect);
            socketTxn.addData({
                connected: connected
            });
            socketTxn.complete();

            if (connected) {
                return;
            }

            connectTxn = cal.createTransaction('CONNECT', connectTxname);
            connectTxn.threadId = threadId;
            connectTxn.addData({
                timeout: options.connectTimeout,
                useAdaptiveTimeout: !!options.useAdaptiveTimeout,
                adaptiveTimeout: options.adaptiveConnectTimeout,
                client: options.clientName,
                transport: options.transportName,
                keepAlive: options.agent && options.agent.options.keepAlive
            });
            socket.once(connectEvent, onSocketConnect);
        }

        function onSocketConnect() {
            var socket = req.socket.pair && req.socket.pair.encrypted || req.socket;

            connectTxn.addData({
                'ssl-r': thing.isFunction(socket.isSessionReused) ? socket.isSessionReused() : false
            });

            if (options.retry) {
                connectTxn.addData({
                    retry: options.retry,
                    maxRetry: options.maxRetry
                });
            }
            timeoutengine.addConnectDuration(options.clientName, connectTxn.duration);
            connectTxn.complete();
        }

        return req;
    };

    return profiler;
};

/**
 * Cal log x-pp-serverinfo header.
 * @param data
 */
function logServerInfo(serverInfoString) {
    var event, serverInfo, poolStack, poolName;
    serverInfo = querystring.parse('PoolStack=' + serverInfoString);

    poolStack = serverInfo.PoolStack;
    poolName = poolStack.substr(0, poolStack.indexOf(':'));

    event = cal.createEvent('SERVER_INFO', poolName);

    event.status = 0;

    event.addData('CurrentPID', process.pid);
    event.addData('ServerPool', poolStack);
    event.addData('CalThreadId', serverInfo.CalThreadId || 0);
    event.addData('TopLevelTxnStartTime', serverInfo.TopLevelTxnStartTime);
    event.addData('Host', serverInfo.Host);
    event.addData('pid', serverInfo.pid || 0);

    event.complete();
}

/**
 * Scrubs PII data.
 * @param path
 */
function scrub(data) {
    var sn, ph, email;

    sn = RegExp(/\d{3}-\d{2}-\d{4}/g);
    ph = RegExp(/\d{3}-\d{3}-\d{4}/g);
    //OWASP safe https://www.owasp.org/index.php/OWASP_Validation_Regex_Repository
    email = RegExp(/[a-zA-Z0-9+&*-]+(?:\.[a-zA-Z0-9_+&*-]+)*@(?:[a-zA-Z0-9-]+\.)+[a-zA-Z]{2,7}/ig);

    data = data.replace(sn, 'xxx-xx-xxxx');
    data = data.replace(ph, 'xxx-xxx-xxxx');
    data = data.replace(email, 'xxx@xxx.xxx');

    return data;
}

exports.scrub = scrub;
